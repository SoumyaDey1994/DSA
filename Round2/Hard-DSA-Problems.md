## Hard Problems

ðŸ§  Dynamic Programming (10 Hard Problems)

1. Edit Distance - Minimum operations to convert one string into another (DP).

2. Burst Balloons - Interval DP â€” maximize coins by choosing optimal balloon burst order.

3. Wildcard Matching - Pattern matching with ? and *.

4. Regular Expression Matching - DP to handle regex with . and *.

5. Palindrome Partitioning II - Min cuts to partition string into palindromes.

6. Longest Increasing Path in a Matrix - DFS + memoization on matrix grid.

7. Interleaving String - Check if s3 is formed by interleaving s1 and s2.

8. Russian Doll Envelopes (2D LIS) - Sort + LIS on second dimension.

9. Maximum Profit in Job Scheduling - Weighted interval scheduling using DP + Binary Search.

10. Distinct Subsequences - Count ways S can form T (classic DP table).

ðŸŽ¯ Backtracking (6 Hard Problems)

11. N-Queens II - Count total ways to place queens.

12. Word Search II - Find all valid words in grid (DFS + pruning).
(Trie version exists, but you can do it with pure DFS too â€” just slower)

13. Sudoku Solver - Full recursive backtracking + constraint pruning.

14. Remove Invalid Parentheses - Generate valid parentheses with minimal removals.

15. Expression Add Operators - Insert +, -, * to form target expression.

16. Restore IP Addresses - Backtracking with segmentation constraints.

ðŸŒ‰ Graph / BFS / DFS Traversal (4 Hard Problems)

17. Word Ladder II - Find all shortest paths between words (BFS + DFS).

18. Shortest Path in Grid with Obstacles Elimination - BFS + state tracking because you can remove up to k obstacles.

19. Minimum Obstacles to Remove (0-1 BFS) - Classic grid traversal with weighted edges.

20. Find Eventual Safe States - Detect nodes that are not part of any cycle (DFS + graph coloring).
